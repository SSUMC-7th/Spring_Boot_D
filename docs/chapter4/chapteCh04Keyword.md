- **DI**

    스프링에서 DI(의존성 주입)는 파라미터나 리턴값, 또는 지역 변수 등으로  
    
    다른 객체를 “외부에서” 주입해 주는 방식을 말한다.  
    
    의존성을 주입하는 방법으로는 크게 3가지 방법이 있다.  
      
    1. 생성자 주입 (권장되는 방법)  
        - 생성자를 통해 의존 관계를 주입 받는 방법으로,  
            
            생성자를 호출할 때 딱 한 번만 호출되기 때문에 주입 받는 객체를 final로 관리할 수 있다.  
            
            주로 주입 받는 객체의 변화가 없거나 반드시 객체의 주입이 필요한 경우에 활용된다.  
            
            또한 컴파일 단계에서 순환참조를 미리 파악할 수 있다.  
              
    2. Setter 주입  
        - Setter 메소드를 통해 의존 관계를 주입 받는 방법으로,  
            
            주로 변경 가능성이 있는 의존 관계에 사용한다.  
            
            생성자 호출 이후에 필드 변수에 변경이 일어나야 하므로, final로 관리할 수 없다.  
            
            만약 @Autowired 로 주입할 객체가 없는 경우 오류가 발생할 수 있다.(빈에 존재하지 않는 경우)  
            
            주입할 객체가 없도록 하려면 @Autowired(required = false) 를 통해 설정이 가능하다.  
              
    3. 필드 주입  
        - 의존 관계를 필드에 그대로 주입하는 방법으로, 코드가 간결하지만  
            
            클래스 외부에서 접근이 불가능해 테스트하기가 어렵다는 단점이 있다.  
              
    
    DI의 장점으로는 다음과 같은 것들이 있다.  
    
    1. 코드의 재활용성을 높여 유지보수가 용이하다.  
    2. 클래스 간 결합도를 낮출 수 있다.  
    3. 인터페이스 기반으로 설계되어 유연한 코드 작성이 가능하다.  
    4. 더 쉽게 단위 테스트를 할 수 있다. 의존성을 외부에서 주입받기 때문에  
        
        테스트 시 모의 객체를 주입하는 방식을 사용할 수 있다.
        
      
    반면 DI의 단점도 존재한다.  
    
    1. 외부에서 의존성을 주입 받기 때문에 코드의 복잡성이 증가할 수 있다.  
    2. 외부에서 의존성으르 주입 받기 때문에 객체 간의 관계 추적이 어려워  
    디버깅이 어려울 수 있다.  
    3. 객체 생성 시에 추가적인 오버헤드가 발생해 성능 저하가 발생할 수 있다.  
    4. DI 프레임워크에 대한 의존성이 증가할 수 있다.  
      
    또한 DI는 SOLID(객체지향 설계 다섯가지 원칙) 중에서  
    
    마지막 원칙인 의존관계 역전 원칙 (Dependency Inversion Principle)을 따른다.  
      
- **IoC**  
    
    IoC(Inversion of Control)는 “제어의 역전”을 의미하며,  
    
    메소드나 객체의 호출작업을 개발자가 아닌 외부, 즉 스프링 프레임워크가 결정하게 된다.  
    
    객체의 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성할 수 있으며,  
    
    가독성 및 유지보수에 도움이 된다.  
      
    기존에는 다음과 같이 객체가 만들어졌다.  
    
    1. 객체 생성  
    2. 클래스 내부에서 의존성 객체 생성  
    3. 의존성 객체 메소드 호출  
      
    그러나 스프링에서는  
    
    1. 객체 생성  
    2. 의존성 객체 주입 (스프링에 위임)   
    3. 의존성 객체 메소드 호출  
    
    이러한 순서로 진행됨으로써 IoC가 실현된다.  
      
    스프링에서 객체 생성 및 의존성을 관리하는 컨테이너를  
    
    IoC 컨테이너라고 한다.  
    
    IoC 컨테이너는  
    
    1. 객체의 생성 및 의존성 관리  
    2. POJO의 생성, 초기화, 서비스, 소멸에 대한 권한 소유  
    
    등을 할 수 있고,  
      
    이를 통해 개발자는 오로지 비즈니스 로직에만 집중할 수 있어  
    
     더 신속하고 집중적인 개발이 가능하다.  
      
    IoC 컨테이너에는 빈 팩토리(Bean Factory)와 어플리케이션컨텍스트(ApplicationContext)가 있다.  
    
    1. 빈 팩토리(Bean Factory)  
        - Bean의 등록, 생성, 조회, 반환 관리를 한다.  
        - 팩토리 디자인 패턴을 구현한 것으로 BeanFactory는 Bean의 생성 및 분배의 책임이 있다.  
        - Bean을 조회할 수 있는 getBean() 메소드가 정의되어 있다.  
      
    2. 어플리케이션컨텍스트(ApplicationContext)  
        - Bean의 등록, 생성, 조회, 반환 관리를 한다. (빈 팩토리와 동일)  
        - 스프링의 각종 부가 기능을 추가로 제공한다.  
      
- **프레임워크와 API의 차이**  
    - 프레임워크는 애플리케이션을 개발하는 데 사용되는 구조를 제공한다.  
    - 프레임워크는 일련의 규칙과 구조를 정의하고, 개발자가 애플리케이션을 작성할 때  
        
        이러한 규칙과 구조를 따르도록 한다.  
        
    - 프레임워크는 보통 여러 컴포넌트와 라이브러리를 포함하며,  
        
        개발자가 특정 기능을 구현하기 위해 이를 조합하여 사용한다.  
        
      
    - API는 두 개 이상의 소프트웨어 컴포넌트 사이에서  
        
        상호 작용할 수 있도록 정의된 인터페이스를 말한다.  
        
    - 일반적으로 함수, 프로토콜, 클래스로 구성되며  
        
        다른 소프트웨어 개발자들이 이를 사용하여 특정 서비스 또는 기능을 사용할 수 있다.  
          
        개인적으로 프로젝트를 하면서 느꼈던 차이점은,  
        
        우선 프레임워크는 개발자가 원하는 서비스를 만들기 위한  
        
        건물의 기초 공사 같은 느낌으로 정해진 매뉴얼에 따라  
        
        기능을 활용해야 하는 느낌이었다.  
          
        반면 API의 경우 이를 적용하기 위한 매뉴얼은 존재하지만,  
        
        개발자가 구성하고자 하는 서비스 내에서 부가 기능을 수행하기 위한 요소라 생각한다.  
        
        종합하면 프레임워크는 서비스 자체를 생성하기 위한 구조물, 뼈대 같은 느낌이라면  
        
        API는 프레임워크로 형성해 놓은 틀 안에서 서비스의 기능을 더욱 풍족하게 하는  
        
        속재료 및 인테리어 같은 느낌이라고 생각한다.  
          
- **AOP**  
    
    AOP(Aspect-Oriented Programming)는 관점 지향 프로그래밍으로,  
    
    관점을 기준으로 다양한 기능을 분리하여 보는 프로그래밍이다.  
    
    관점이란, 부가 기능과 그 적용처를 정의하고 합쳐서 모듈로 만든 것이다.  
      
    AOP는 OOP를 보완하기 위해 사용된다.  
    
    기존의 객체 지향은 목적에 따라 클래스와 객체를 만들기 때문에,  
    
    객체를 분리하는 데 그치고 이 기능들을 어떻게 바라보고 나눌 것인지에 대한  
    
    정의가 부족하다는 단점이 있다.  
      
    핵심 비즈니스 로직으로부터 부가 기능 로직(로깅, 보안, 트랜잭션)을 분리하여  
    
    코드의 간결성을 높이고 변경에 유연함과 무한한 확장이 가능하도록 하는 것이  
    
    AOP의 목적이다.  
      
    AOP를 적용하는 방식은 아래와 같다.  
    
    1. 컴파일 시점 적용  
    2. 클래스 로딩 시점 적용  
    3. 런타임 시점 적용  
      
     스프링 AOP는 런타임 시점에 적용하는 방식을 사용한다.  
    
    컴파일 시점이나 클래스 로딩 시점에 적용하려면 별도의 컴파일러와  
    
    클래스로더 조작기를 써야 하는데, 이것을 정하고 사용 및 유지하는 과정이  
    
    매우 어렵고 복잡하기 때문이다.  
      
    [AOP 용어 및 개념]  
    
    1. Aspect  
        a. 공통 기능  
        b. Advice + Pointcut을 모듈화한 애플리케이션의 횡단 기능  
    2. Join Point  
        a. 애플리케이션 실행 흐름에서의 특정 포인트  
        b. ex) 클래스 초기화, 메서드 호출, 예외 발생 등  
        c. AOP를 적용할 수 있는 모든 지점을 의미 (스프링에서는 메소드 실행 지점으로 제한)  
    3. Advice  
        a. Join Point에서 실행되는 코드 및 부가기능 그 자체  
        b. Aspect를 언제 핵심 코드에 적용할지 정의  
    4. Pointcut  
        a. Join Point 중 Advice가 적용될 지점을 선별하는 기능  
        b. 주로 AspectJ 표현식으로 지정  
    5. Target  
        a. 핵심 기능을 담은 모듈 (부가 기능 부여 대상)  
        b. Advice를 받는 객체이며, Pointcut으로 결정됨  
    6. Advisor  
        a. 스프링 AOP에서만 쓰는 용어로, 하나의 Advice돠  
            
            하나의 Pointcut으로 구성된 Aspect를 특별하게 지칭하는 말  
              
- **서블릿**  
    
    서블릿(Servlet)은 동적 웹 페이지 기술을 만들 때 사용되는  
    
    자바 기반 웹 애플리케이션 프로그래밍 기술이다.  
    
    서블릿은 웹 요청과 응답의 흐름을 간단한 메소드 호출 만으로  
    
    체계적으로 다룰 수 있게 해 준다.  
      
    서블릿의 특징  
    
    - 클라이언트의 Request에 대해 동적으로 작동하는 웹 애플리케이션 컴포넌트  
    - 기존의 정적 웹 프로그램의 문제점을 보완하여 동적인 여러 가지 기능을 제공함  
    - 자바의 스레드를 이용하여 동작함  
    - MVC 패턴의 컨트롤러에 해당됨  
    - 컨테이너에서 실행됨  
    - 보안 기능을 적용하기 쉬움  
  
서블릿의 동작 과정  

1. 클라이언트 요청  
2. HttpServletRequest, HttpServletResponse 객체 생성  
3. Web.xml이 어느 서블릿에 대해 요청한 것인지 탐색  
4. 해당하는 서블릿에서 service() 메소드 호출  
5. doGet() 또는 doPost() 호출  
6. 동적 페이지 생성 후 HttpServletResponse 객체에 응답 전송  
7. HttpServletRequest, HttpServletResponse 객체 소멸  
  
서블릿의 생명 주기  

: 서블릿도 자바 클래스이므로 초기화, 서비스 수행, 소멸의 과정을 거치며,  

이를 서블릿의 생명 주기라 한다. 이때 각 단계마다 호출되어 기능을 수행하는  

콜백 메서드를 서블릿 생명주기 메서드라 한다.  
  
[서블릿 생명주기 메서드]  

- 초기화 : init()  
    - 서블릿 요청시 처음 한 번만 호출  
    - 주로 서블릿 생성 시 초기화 작업 수행  
- 작업 수행 : doGet(), doPost()  
    - 서블릿 요청 시 매번 호출  
    - 실제로 클라이언트가 요청하는 작업 수행  
- 종료 : destroy()  
    - 서블릿이 기능을 수행하고 메모리에서 소멸될 때 호출  
    - 주로 서블릿의 마무리 작업 수행  
  
서블릿 컨테이너  

: 구현되어 있는 서블릿 클래스의 규칙에 맞게 서블릿을 담고 관리해주는 컨테이너  
  
서블릿 컨테이너의 기능  

- 웹 서버와의 통신 지원  
- 서블릿 생명 주기 관리  
- 멀티쓰레드 지원 및 관리  
- 선언적인 보안 관리  
