*6주차 키워드*  
  
- **지연로딩과 즉시로딩의 차이**  
    - 먼저 FetchType이란, JPA가 하나의 엔티티를 조회할 때 연관관계에 있는 객체들을  
    어떻게 가져올지 나타내는 설정값을 말한다.  
    JPA는 ORM 기술로, 사용자가 직접 쿼리를 생성하지 않고 JPA에서 JPQL을 이용하여  
    쿼리문을 생성하기 때문에 객체와 필드를 보고 쿼리를 생성한다.  
    따라서 다른 객체와 연관관계 매핑이 되어 있으면 그 객체들까지 조회하게 되는데,  
    이때 이 객체를 어떻게 불러올 것인지 설정할 수 있다.  
    - fetch의 디폴트 값은 @~ToOne에서는 Eager, @~ToMany에서는 Lazy이다.  
    - 즉시로딩(Eager)  
        - 즉시로딩이란 데이터를 조회할 때 연관된 모든 객체의 데이터를  
        한 번에 불러오는 것이다.  
        - 즉시로딩을 적용하면 예상하지 못한 SQL이 발생하여,  
        JPQL에서 N+1 문제를 일으킬 수 있다.  
        - 따라서 실무에서는 가급적 지연로딩이 사용된다.  
        이때 지연로딩으로 설정해 놓았지만 특정 시점에 즉시로딩과 같은 효과가 필요하다면  
        Fetch Join을 통해 쿼리를 한 번에 가져올 수 있다.  
    - 지연로딩(Lazy)  
        - 지연로딩이란 필요한 시점에 연관된 객체의 데이터를 불러오는 것이다.  
        - 로딩되는 시점에 Lazy 로딩 설정이 되어있는 엔티티는 프록시 객체로 가져오고,  
        후에 실제 객체를 사용하는 시점에 초기화가 된다.  
        - 지연로딩을 통해 쿼리의 최적화와 성능 향상을 도모할 수 있으나,  
        연관 엔티티를 사용하는 과정에서 DB 쿼리가 추가적으로 발생할 수 있다.  
          
- **Fetch Join**  
    - Fetch Join은 JPQL에서 성능 최적화를 위해 제공하는 기능으로,  
    지연로딩으로 설정되어 있는 연관관계를 조인쿼리를 통해 한 번에 조회할 수 있도록 한다.  
    - JOIN FETCH 명령어를 통해 사용할 수 있다. Ex) `SELECT m FROM Member m JOIN FETCH m.team`  
    - Fetch Join은 글로벌 로딩 전략(fetch = FetchType.LAZY)보다 우선된다.  
    - Fetch Join vs 일반 Join  
        - Fetch Join은 ORM에서의 사용을 전제로 DB 스키마를 엔티티로 자동 변환 해 주고  
        영속성 컨텍스트에 영속화를 해 준다.  
        - 따라서 Fetch Join을 통해 조회하면 연관 관계는 영속성 컨텍스트 1차 캐시에  
        저장 되어 다시 엔티티 그래프를 탐색하더라도 조회 쿼리가 수행되지 않는다.  
        - 반면 일반 Join 쿼리는 단순히 데이터를 조회하는 개념으로 영속성 컨텍스트나  
        엔티티와는 무관하다.  
        - 따라서 가능하다면 Fetch Join을 활용해야 ORM을 활용하여  
        관계형 데이터베이스와의 패러다임 차이를 줄일 수 있다.  
    - Fetch Join의 한계  
        - Fetch Join 대상에는 별칭을 줄 수 없다.  
            - JPA 표준에서는 지원하지 않지만 hibernate를 포함한 몇몇 구현체들은  
            별칭을 지원한다. 다만 별칭을 잘못 사용하면 연관된 데이터 수가 달라져  
            데이터 무결성이 깨질 수 있으므로 사용하지 않는 것이 좋다.  
        - 둘 이상의 컬렉션을 fetch 할 수 없다.  
            - 구현체에 따라 가능할 수도 있지만, 컬렉션 * 컬렉션의 카테시안 곱이  
            만들어지므로 주의해야 한다. hibernate를 사용하면 예외가 발생한다.  
        - 컬렉션을 Fetch Join 하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.  
            - 컬렉션(일대다)이 아닌 단일 값 연관 필드(일대일, 다대일)들은 Fetch Join을  
            사용해도 페이징 API를 사용할 수 있다.  
            - hibernate에서 컬렉션을 Fetch Join하고 페이징 API를 사용하면  
            경고 로그가 발생한다.  
              
- **@EntityGraph**  
    - 엔티티 그래프는 엔티티 조회 시점에 연관된 엔티티들을 함께 조회하는 기능으로,  
    Fetch Join과 더불어 N+1 문제를 해결하고, 성능 최적화를 위해 활용된다.  
    - 다만 Fetch Join을 사용하기 위해서는 JPQL을 사용해야만 하기 때문에  
    JPARepository 인터페이스가 기본적으로 제공하는 기본 메소드들에는 사용할 수 없다.  
    그런 상황에서 사용할 수 있는 것이 바로 엔티티 그래프이다.  
    - 엔티티 그래프를 사용하기 위해서는 Repository에 공통 메소드를 오버라이딩하면서  
    @EntityGraph 어노테이션을 붙이면 된다. 이때 꼭 연관관계 필드명을 넣어주어야 한다.  
    - 엔티티 그래프는 left outer join만 지원하기 때문에 다른 방식이 필요하면  
    직접 JPQL을 작성해 Fetch Join을 사용해야 한다.  
    - 엔티티 그래프의 Type  
        - @EntityGraph.EntityGraphType.FETCH : 엔티티 그래프에 명시한 속성은  
        EARER로 패치하고, 나머지 속성은 LAZY로 패치  
        - @EntityGraph.EntityGraphType.LOAD : 엔티티 그래프에 명시한 속성은 EAGER로  
        패치하고, 나머지 속성은 엔티티에 명시한 FetchType이나 디폴트 FetchType으로 패치
  
- **JPQL**  
    - JPQL(Java Persistence Query Language)은 객체 지향 쿼리로 JPA가 지원하는  
    다양한 쿼리 방법(JPQL, JPA Criteria, QueryDSL, 네이티브 SQL 등) 중 하나이다.  
    - SQL은 테이블을 대상으로 쿼리하지만, JPQL은 엔티티 객체를 대상으로 쿼리한다.  
    - JPQL은 SQL을 추상화 했기 때문에 특정 데이터베이스 SQL에 의존하지 않는 장점이 있다.  
    - JPQL은 SQL과 문법이 유사하며, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN을  
    지원한다.  
    - JPQL의 기본 함수에는 CONCAT, SUBSTRING, TRIM, LOWER, UPPER, LENGTH, LOCATE,  
    ABS, SQRT, MOD, SIZE, INDEX 등이 있다.  
    - JPQL의 특징  
        - 엔티티와 속성은 대소문자를 구분한다.  
        - @Entity의 name을 지정하지 않으면 클래스 이름이 엔티티 이름이다.  
        - JPQL 키워드는 대소문자를 구분하지 않는다.  
        - 별칭 사용은 필수적이다.  
        - AS는 생략이 가능하다.  
        - From 절에는 객체가 들어간다.  
    - JPQL의 단점  
        - JPQL은 기본 문자열로 작성되기 때문에 컴파일 시 에러를 발생하지 않는다.  
        따라서 문제가 있음에도 불구하고 정상적으로 작동하여 배포 시 문제가 발생할 수 있다.  
        - 동적으로 쿼리 언어를 작성하는 데 효율적이지 못하다.
        
- **QueryDSL**  
    - QueryDSL은 hibernate 쿼리 언어의 쿼리를 타입에 안전하게  
    생성 및 관리해주는 프레임워크이다.  
    - QueryDSL은 정적 타입을 이용하여 SQL과 같은 쿼리를 생성할 수 있게 해 준다.  
    - 자바 백엔드 기술은 Spring Boot와 Spring Data JPA를 함께 사용한다.  
    하지만 복잡한 쿼리, 동적 쿼리를 구현하는 데 있어 한계가 있다.  
    이러한 문제점을 해결할 수 있는 것이 QueryDSL이다.  
    - QueryDSL이 등장하기 이전에는 Mybatis, JPQL, Criteria 등 문자열 형태로 쿼리문을  
    작성하여 컴파일 시에 오류를 발견하는 것이 불가능했다.  
    하지만 QueryDSL은 자바 코드로 SQL 문을 작성할 수 있어 컴파일 시에 오류를 발생하여   
    잘못된 쿼리가 실행되는 것을 방지할 수 있다.  
    - QueryDSL의 장점  
        - 문자가 아닌 코드로 쿼리를 작성할 수 있어 컴파일 시점에 문법 오류를 확인할 수 있다.  
        - IDE의 자동 완성 기능의 도움을 받을 수 있다.  
        - 복잡한 쿼리나 동적 쿼리 작성이 편리하다.  
            - JPQL을 이용해 동적 쿼리를 다루기 위해서는 문자열을 조건에 맞게 조합해서  
            사용해야 한다. 이는 코드도 복잡해지고 런타임 에러를 발생시키는 치명적인  
            단점이 있다. QueryDSL은 복잡한 동적 쿼리도 Q클래스, 메소드를 활용하여  
            쉽게 다룰 수 있다.  
        - 쿼리 작성 시 제약 조건 등을 메서드 추출을 통해 재사용할 수 있다.  
        - JPQL 문법과 유사하다. (SELECT, FROM, WHERE, JOIN)  
    - QueryDSL의 단점  
        -엔티티가 많아질수록 QueryDSL Q클래스가 커진다.  
        - QueryDSL 설정이 다소 복잡할 수 있다.  
        - 별도로 라이브러리를 설치해야 하며, QueryDSL도 메이저 라이브러리가 아니다 보니  
        추후 지원이 안 되는 경우가 발생할 수 있다.
  
- **N+1 문제를 해결하기 위한 다양한 해결법**  
    - N + 1 문제란 ORM 기술에서 특정 객체를 대상으로 수행한 쿼리가 해당 객체가 가지고 있는  
    연관 관계 또한 조회하게 되면서 N번의 추가적인 쿼리가 발생하는 문제를 말한다.  
    - N +1 문제 해결 방법  
        1. Eager Loading으로 N + 1 문제를 해결하려고 하면 안 된다.  
            - Eager Loading : 연관된 엔티티 객체를 한 번에 조회하도록 하는 기능으로,  
            특정 경우에 N + 1 문제를 부분적으로 해결해 줄 수 있지만 사용하지 않는 것이 좋다.  
            - 어떤 엔티티 범위까지 조인 쿼리로 조회할지 예상하기 힘들어지기 때문에  
            오히려 필요 없는 데이터까지 로딩하여 비효율적일 수 있다.  
              
        2. Fetch Join + Lazy Loading  
            - Fetch Join : 루트 엔티티에 대해 조회할 때 Lazy Loading으로 설정되어 있는  
            연관 관계를 조인 쿼리를 통해 한 번에 조회할 수 있는 기능  
            - Fetch Join vs 일반 Join  
                - Fetch Join은 ORM에서의 사용을 전제로 DB 스키마를 엔티티로 자동 변환 해 주고  
                영속성 컨텍스트에 영속화를 해 준다.  
                - 따라서 Fetch Join을 통해 조회하면 연관 관계는 영속성 컨텍스트 1차 캐시에  
                저장 되어 다시 엔티티 그래프를 탐색하더라도 조회 쿼리가 수행되지 않는다.  
                - 반면 일반 Join 쿼리는 단순히 데이터를 조회하는 개념으로 영속성 컨텍스트나  
                엔티티와는 무관하다.  
                - 따라서 가능하다면 Fetch Join을 활용해야 ORM을 활용하여  
                관계형 데이터베이스와의 패러다임 차이를 줄일 수 있다.  
                  
        3. Batch Size  
            - Lazy Loading시 프록시 객체를 조회할 때 WHERE IN 절로 묶어서  
            한 번에 조회할 수 있도록 해 주는 옵션  
            - yml에 전역 옵션으로 적용할 수 있고 @BatchSize를 통해 연관 관계 Batch Size를  
            다르게 적용할 수 있다.  
            - Batch Size는 100 ~ 1000 정도로 적용하고, DBMS에 따라서 1000까지 제한하는  
            경우가 있어 그 이상은 잘 설정하지 않는다.  
              
        4. Fetch Join vs Batch Size  
            - 쿼리 개수 관점 : 쿼리 개수는 Fetch Join이 유리하다. Batch Size의 경우  
            몇 번의 추가적인 쿼리가 더 발생할 수 있다.  
            - 데이터 전송량 관점 : 데이터 전송량 관점에서는 Batch Size가 유리하다.  
            Fetch Join은 조인을 하고 나서 가져오기 때문에 중복 데이터를 더 많이 가져온다.  
              
        5. 일반 Join 후 Projection 하여 특정 컬럼만 Dto로 조회  
            - 장점 : 엔티티 컬럼이 많을 때 Projection 하여 특정 컬럼만 조회할 수 있고, 커버링 인덱스  
            활용 가능성이 상승한다.  
            - 단점 : 영속성 컨텍스트와 무관하게 동작하고 Repository가 Dto에 의존하게 되기 때문에  
            API 변경에 Dao도 수정되어야 할 수 있다.  
            - 이 방식을 사용하는 쿼리는 Dao를 분리하는 것이 좋다.  
              
        6. @EntityGraph  
            - Fetch Join의 경우 하나의 컬렉션까지만 같이 Join 하여 조회할 수 있지만,  
            엔티티 그래프는 여러 일대다 연관 관계를 한 번에 Join 할 수 있다.  
      
    - 실무에서는 지연 로딩 + Fetch Join을 활용하는 방법을 많이 사용한다.
