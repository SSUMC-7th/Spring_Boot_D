*5주차 키워드*  

- Domain

    스프링에서의 도메인은 실제 DB 테이블과 매핑시키는 클래스를 말한다.  
    도메인은 일반적인 요구 사항, 전문 용어, 그리고 컴퓨터 프로그래밍 분야에서  
    문제를 풀기 위해 설계된 어떤 소프트웨어 프로그램에 대한 기능성을 정의하는  
    연구의 한 영역이다.

    도메인 객체는 비즈니스 로직을 수행하고, 데이터의 일관성을 보장하며,  
    엔티티 간 관계를 관리하는 책임을 가진다.

    `@Entity` 어노테이션을 통해 DB 테이블과 매칭될 클래스임을 나타내고,  
    `@Builder` 어노테이션을 통해 객체 생성 시점에 값을 넣어줄 수 있다.

    **도메인과 엔티티의 차이점 :**

    도메인은 비즈니스 영역을 추상적으로 나타내는 개념이고,  
    엔티티는 도메인 내에서 실제 개별 객체나 개념을 나타낸다.  

    즉, 도메인은 서비스를 대표하는 개념이고 엔티티는 도메인 내에  
    식별 가능한 객체를 뜻한다.

---

- 양방향 매핑

    (다대일) 양방향 매핑은 다대일 단방향 매핑과 일대다 단방향 매핑을 함께 사용하는 형태이다.  

    양방향 매핑 시 참조 테이블의 외래키를 관리하는 객체를 연관관계의 주인이라고 한다.  

    연관관계의 주인 만이 데이터베이스 연관관계와 매핑되고 외래키를 관리할 수 있다.  

    주인이 아닌 테이블은 참조 필드를 통해서 읽기만 가능하다.  

    연관관계의 주인은 `mappedBy` 속성을 활용하여 지정한다.  

    - 주인은 `mappedBy` 속성을 사용하지 않는다.  
    - 주인이 아닌 테이블은 `mappedBy` 속성을 이용해  
      속성의 값으로 연관관계의 주인을 지정해야 한다.

    양방향 연관관계에서는 양쪽 모두 관계를 맺어주어야  
    순수한 객체 상태에서도 정상적으로 동작한다.

    이때 연관관계를 설정하는 메서드를 연관관계 메서드라 하고,  

    참조하는 객체와 참조되는 객체에서 **한 번에** 연관관계를 설정할 수 있도록  

    하나의 코드로 작용하는 것을 연관관계 편의 메서드라고 한다.

    양방향 매핑은 데이터 조회 시 편리함을 제공하지만,  

    복잡성을 증가시키고 성능 문제를 일으킬 수 있다.

    따라서 데이터 조회가 빈번한 경우에 유리하지만, 두 엔티티 간의 참조 관계를 유지하기 위해  

    추가적인 메모리와 처리 시간이 필요하기 때문에 유지보수가 어려울 수 있다.

---

- N + 1 문제

    N + 1 문제란 ORM 기술에서 특정 객체를 대상으로 수행한 쿼리가 해당 객체가 가지고 있는  

    연관 관계 또한 조회하게 되면서 N번의 추가적인 쿼리가 발생하는 문제를 말한다.

    N + 1 문제가 발생하는 근본적인 원인은 관계형 데이터베이스와 객체지향 언어 간의  

    패러다임 차이로 인해 발생한다. 객체는 연관 관계를 통해 레퍼런스를 가지고 있으면  

    언제든지 메모리 내에서 Random Access를 통해 연관 객체에 접근할 수 있지만,  

    관계형 데이터베이스의 경우 Select 쿼리를 통해서만 조회할 수 있기 때문이다.

    N +1 문제가 발생하면 쿼리가 배수적으로 증가하면서 DB에 큰 부담이 발생하게 되고  
    장애 요인이 될 수 있다. 또한 사용자 관점에서 지연율 또한 크게 증가할 수 있다.

    결론적으로 N + 1 문제를 해결하지 않으면 양방향 매핑을 했을 때의  

    장점이 퇴색될 수 있을 것 같다는 생각이 들었다.

    **N +1 문제 해결 방법**

    1. **Eager Loading으로 N + 1 문제를 해결하려고 하면 안 된다.**  
       - Eager Loading : 연관된 엔티티 객체를 한 번에 조회하도록 하는 기능으로,  
         특정 경우에 N + 1 문제를 부분적으로 해결해 줄 수 있지만 사용하지 않는 것이 좋다.  
       - 어떤 엔티티 범위까지 조인 쿼리로 조회할지 예상하기 힘들어지기 때문에  
         오히려 필요 없는 데이터까지 로딩하여 비효율적일 수 있다.

    2. **Fetch Join + Lazy Loading**  
       - Fetch Join : 루트 엔티티에 대해 조회할 때 Lazy Loading으로 설정되어 있는  
         연관 관계를 조인 쿼리를 통해 한 번에 조회할 수 있는 기능  
       - **Fetch Join vs 일반 Join**  
         - Fetch Join은 ORM에서의 사용을 전제로 DB 스키마를 엔티티로 자동 변환해 주고  
           영속성 컨텍스트에 영속화를 해 준다.  
         - Fetch Join을 통해 조회하면 연관 관계는 영속성 컨텍스트 1차 캐시에  
           저장되어 다시 엔티티 그래프를 탐색하더라도 조회 쿼리가 수행되지 않는다.  
         - 반면 일반 Join 쿼리는 단순히 데이터를 조회하는 개념으로 영속성 컨텍스트나  
           엔티티와는 무관하다.  
         - 따라서 가능하다면 Fetch Join을 활용해야 ORM을 활용하여  
           관계형 데이터베이스와의 패러다임 차이를 줄일 수 있다.

    3. **Batch Size**  
       - Lazy Loading 시 프록시 객체를 조회할 때 WHERE IN 절로 묶어서  
         한 번에 조회할 수 있도록 해 주는 옵션  
       - yml에 전역 옵션으로 적용할 수 있고 `@BatchSize`를 통해 연관 관계 Batch Size를  
         다르게 적용할 수 있다.  
       - Batch Size는 100 ~ 1000 정도로 적용하고, DBMS에 따라서 1000까지 제한하는  
         경우가 있어 그 이상은 잘 설정하지 않는다.

    4. **Fetch Join vs Batch Size**  
       - **쿼리 개수 관점** : 쿼리 개수는 Fetch Join이 유리하다. Batch Size의 경우  
         몇 번의 추가적인 쿼리가 더 발생할 수 있다.  
       - **데이터 전송량 관점** : 데이터 전송량 관점에서는 Batch Size가 유리하다.  
         Fetch Join은 조인을 하고 나서 가져오기 때문에 중복 데이터를 더 많이 가져온다.

